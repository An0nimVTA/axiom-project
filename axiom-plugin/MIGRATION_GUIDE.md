# Руководство по миграции на новую архитектуру

## Введение

Этот документ описывает процесс постепенной миграции с текущей архитектуры на новую, чистую архитектуру.

## Текущее состояние

- Все существующие классы остаются на своих местах
- Созданы новые пакеты для организованной структуры
- Созданы адаптерные классы для совместимости

## Процесс миграции

### Фаза 1: Подготовка (текущая)
1. ✅ Созданы новые пакеты
2. ✅ Создана документация
3. ✅ Созданы адаптерные классы
4. ✅ Созданы интерфейсы для ключевых сервисов

### Фаза 2: Постепенная замена
1. Создать новые реализации сервисов, реализующие интерфейсы
2. Постепенно заменять вызов legacy методов на новые
3. Тестировать каждый шаг
4. Удалять legacy код только после полной замены

### Фаза 3: Оптимизация
1. Улучшение производительности
2. Добавить кэширование
3. Оптимизировать запросы к данным

## Пример миграции сервиса

### До:
```java
// Старый способ
MilitaryService service = new MilitaryService(plugin);
double strength = service.getMilitaryStrength(nationId);
```

### После:
```java
// Новый способ
MilitaryServiceInterface service = new MilitaryServiceImpl(plugin);
double strength = service.getMilitaryStrength(nationId);
```

### Промежуточный (с адаптером):
```java
// Через адаптер
MilitaryServiceInterface service = new MilitaryServiceAdapter(plugin);
double strength = service.getMilitaryStrength(nationId);
```

## Правила миграции

1. **Не ломать существующий функционал** - все должно продолжать работать
2. **Постепенная замена** - мигрировать по одному компоненту
3. **Тестирование** - каждый шаг должен быть протестирован
4. **Документация** - обновлять документацию после каждого изменения
5. **Совместимость** - поддерживать обратную совместимость во время миграции

## План миграции компонентов

1. MilitaryService → MilitaryServiceInterface
2. SiegeService → SiegeServiceInterface
3. EconomyService → EconomyServiceInterface
4. DiplomacySystem → DiplomacyServiceInterface
5. NationManager → NationServiceInterface

## Ожидаемые преимущества

- Более чистый и организованный код
- Легкость тестирования
- Улучшенная поддержка
- Возможность легкого расширения
- Лучшая производительность
